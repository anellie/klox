package xyz.angm.lox

/** This file is autogenerated using [xyz.angm.lox.tool.defineAst]. DO NOT EDIT DIRECTLY! */
abstract class Expression {

    abstract fun <R> accept(visitor: Visitor<R>): R

    interface Visitor<R> {
        fun visitAssignExpression(expression: Assign): R
        fun visitBinaryExpression(expression: Binary): R
        fun visitCallExpression(expression: Call): R
        fun visitGroupingExpression(expression: Grouping): R
        fun visitLiteralExpression(expression: Literal): R
        fun visitLogicalExpression(expression: Logical): R
        fun visitUnaryExpression(expression: Unary): R
        fun visitTernaryExpression(expression: Ternary): R
        fun visitVariableExpression(expression: Variable): R
    }

    class Assign(
        val name: Token,
        val value: Expression
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitAssignExpression(this)
    }

    class Binary(
        val left: Expression,
        val operator: Token,
        val right: Expression
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitBinaryExpression(this)
    }

    class Call(
        val callee: Expression,
        val paren: Token,
        val arguments: List<Expression>
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitCallExpression(this)
    }

    class Grouping(
        val expression: Expression
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitGroupingExpression(this)
    }

    class Literal(
        val value: Any?
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitLiteralExpression(this)
    }

    class Logical(
        val left: Expression,
        val operator: Token,
        val right: Expression
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitLogicalExpression(this)
    }

    class Unary(
        val operator: Token,
        val right: Expression
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitUnaryExpression(this)
    }

    class Ternary(
        val condition: Expression,
        val isTrue: Expression,
        val isFalse: Expression
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitTernaryExpression(this)
    }

    class Variable(
        val name: Token
    ) : Expression() {
        override fun <R> accept(visitor: Visitor<R>) = visitor.visitVariableExpression(this)
    }

}
